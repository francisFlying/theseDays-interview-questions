<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>自己的收集</title>
</head>
<body>
	
<script type="text/javascript">
	//谈谈你对webpack的看法：
		//WebPack 是一个模块打包工具，你可以使用WebPack管理你的模块依赖，并编绎输出模块们所需的静态文件。它能够很好地管理、打包Web开发中所用到的HTML、JavaScript、CSS以及各种静态文件（图片、字体等），让开发过程更加高效。对于不同类型的资源，webpack有对应的模块加载器。webpack模块打包器会分析模块间的依赖关系，最后 生成了优化且合并后的静态资源。
	//webpack的两大特色：
		//1.code splitting（可以自动完成）
		//2.loader 可以处理各种类型的静态文件，并且支持串联操作
	//webpack 是以commonJS的形式来书写脚本滴，但对 AMD/CMD 的支持也很全面，方便旧项目进行代码迁移。
	//webpack具有requireJs和browserify的功能，但仍有很多自己的新特性：
		//1. 对 CommonJS 、 AMD 、ES6的语法做了兼容
		//2. 对js、css、图片等资源文件都支持打包
		//3. 串联式模块加载器以及插件机制，让其具有更好的灵活性和扩展性，例如提供对CoffeeScript、ES6的支持
		//4. 有独立的配置文件webpack.config.js
		//5. 可以将代码切割成不同的chunk，实现按需加载，降低了初始化时间
		//6. 支持 SourceUrls 和 SourceMaps，易于调试
		//7. 具有强大的Plugin接口，大多是内部插件，使用起来比较灵活
		//8.webpack 使用异步 IO 并具有多级缓存。这使得 webpack 很快且在增量编译上更加快

/************************************************************************************************/		
				
//说说你对作用域链的理解：
	//作用域链的作用是保证执行环境里有权访问的变量和函数是有序的，作用域链的变量只能向上访问，变量访问到window对象即被终止，作用域链向下访问变量是不被允许的。

/************************************************************************************************/

//创建ajax过程：
	//(1)创建XMLHttpRequest对象,也就是创建一个异步调用对象.
	//(2)创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息.
	//(3)设置响应HTTP请求状态变化的函数.
	//(4)发送HTTP请求.
	//(5)获取异步调用返回的数据.
	//(6)使用JavaScript和DOM实现局部刷新.	
//ajax过程代码演示：
	//点击发送按钮 创建XMLHttpRequest对象 
	// XMLHttpRequest 具备和后台服务器通信的能力
	// 只要和后台服务器 通信 必须http 协议
    document.querySelector('button').onclick=function(){
    	var  xhr=new XMLHttpRequest();
	   	//模拟http协议 请求报文
	   	//请求行
	   	xhr.open('get','01-ajax.php');
	   	//请求头
	   	xhr.setRequestHeader('Content-Type','text/html');
	   	//请求主体 get  null   执行到此  请求就会发送出去  
	   	xhr.send(null);
	//我们的请求发送出去之后，不能确定响应何时返回（由于网络各种外界原因）。所以 用一个事件来持续 监听 服务器的响应， 服务器响应后就会触发事件--
	   	xhr.onreadystatechange=function(){
	   		//表示服务器请求处理完成，并且成功处理请求
	   		if(xhr.readyState==4&&xhr.status==200){
	   				//拿到服务器返回 内容
	   			console.log(xhr.responseText);
	   			document.querySelector('.info').innerHTML=xhr.responseText;
	   		}
	   	}
    }	

//下面是自己总结的关于ajax的一些东西，篇幅较长；

//什么是ajax：
	//AJAX是“Asynchronous JavaScript and XML”的缩写。它是指一种创建交互式网页应用的网页开发技术。
	
//Ajax包含下列技术：
	//基于web标准（standards-basedpresentation）XHTML+CSS的表示；
	//使用 DOM（Document ObjectModel）进行动态显示及交互；
	//使用 XML 进行数据交换及相关操作；
	//使用 XMLHttpRequest 进行异步数据查询、检索；
	//使用 JavaScript 将所有的东西绑定在一起。

//为什么要用ajax：
	//Ajax应用程序的优势在于：
		//1. 通过异步模式，提升了用户体验
		//2. 优化了浏览器和服务器之间的传输，减少不必要的数据往返，减少了带宽占用
		//3. Ajax引擎在客户端运行，承担了一部分本来由服务器承担的工作，从而减少了大用户量下的服务器负载。
	//AJAX最大的特点是什么：
		//Ajax可以实现页面局部刷新
		//就是能在不更新整个页面的前提下维护数据。这使得Web应用程序更为迅捷地回应用户动作，并避免了在网络上发送那些没有改变过的信息。
	//ajax的缺点：
		//1、ajax不支持浏览器back按钮。
		//2、安全问题 AJAX暴露了与服务器交互的细节。
		//3、对搜索引擎的支持比较弱。
		//4、破坏了程序的异常机制。
		//5、不容易调试。

//请介绍一下XMLhttprequest对象：
	//Ajax的核心是JavaScript对象XmlHttpRequest。它是一种支持异步请求的技术。简而言之，XmlHttpRequest使您可以使用JavaScript向服务器提出请求并处理响应，而不阻塞用户。通过XMLHttpRequest对象，Web开发人员可以在页面加载以后进行页面的局部更新。

//Ajax代码基本流程：
	//点击发送按钮 创建XMLHttpRequest对象 
	// XMLHttpRequest 具备和后台服务器通信的能力
	// 只要和后台服务器 通信 必须http 协议
    	document.querySelector('button').onclick=function(){
    		var  xhr=new XMLHttpRequest();
	    	//模拟http协议 请求报文
	    	//请求行
	    	xhr.open('get','01-ajax.php');
	    	//请求头
	    	xhr.setRequestHeader('Content-Type','text/html');
	    	//请求主体 get  null   执行到此  请求就会发送出去  
	    	xhr.send(null);
	//我们的请求发送出去之后，不能确定响应何时返回（由于网络各种外界原因）。所以 用一个事件来持续 监听 服务器的响应， 服务器响应后就会触发事件--
	    	xhr.onreadystatechange=function(){
	    		//表示服务器请求处理完成，并且成功处理请求
	    		if(xhr.readyState==4&&xhr.status==200){
	    				//拿到服务器返回 内容
	    			console.log(xhr.responseText);
	    			document.querySelector('.info').innerHTML=xhr.responseText;
	    		}
	    	}
    	}

//AJAX应用和传统Web应用有什么不同：
	//在传统的Javascript编程中，如果想得到服务器端数据库或文件上的信息，或者发送客户端信息到服务器，需要建立一个HTML form然后GET或者POST数据到服务器端。用户需要点击”Submit”按钮来发送或者接受数据信息，然后等待服务器响应请求，页面重新加载。
	//因为服务器每次都会返回一个新的页面， 所以传统的web应用有可能很慢而且用户交互不友好。
	//使用AJAX技术， 就可以使Javascript通过XMLHttpRequest对象直接与服务器进行交互。
	//通过HTTP Request， 一个web页面可以发送一个请求到web服务器并且接受web服务器返回的信息(不用重新加载页面)，展示给用户的还是通一个页面，用户感觉页面刷新，也看不到到Javascript后台进行的发送请求和接受响应。

//Ajax和JavaScript的区别：
	//javascript是一种在浏览器端执行的脚本语言，Ajax是一种创建交互式网页应用的开发技术 ，它是利用了一系列相关的技术其中就包括javascript。

//在 Ajax应用中信息是如何在浏览器和服务器之间传递的：
	//通过XML数据或者字符串；

//XMLHttpRequest对象在IE和Firefox中创建方式有没有不同：
	//有，IE中通过new ActiveXObject()得到，Firefox中通过newXMLHttpRequest()得到；

//Ajax技术的核心是XMLHttpRequest对象（简称XHR），可以通过使用XHR对象获取到服务器的数据，然后再通过DOM将数据插入到页面中呈现。虽然名字中包含XML，但Ajax通讯与数据格式无关，所以我们的数据格式可以是XML或JSON等格式。
/************************************************************************************************/

//浅谈一下渐进增强和优雅降级：
	//渐进增强 ：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。
	//优雅降级 ：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。

/************************************************************************************************/

//前段性能优化总结：
	//1、减少http请求，合理设置 HTTP缓存
	//2、使用浏览器缓存
	//3、启用压缩
	//4、CSS Sprites
	//5、LazyLoad Images
	//6、CSS放在页面最上部，javascript放在页面最下面
	//7、异步请求Callback（就是将一些行为样式提取出来，慢慢的加载信息的内容）
	//8、减少cookie传输
//代码层面的优化：
	//少用全局变量
	//用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能
	//用setTimeout来避免页面失去响应
	//缓存DOM节点查找的结果
	//避免全局查询
	//避免使用with(with会创建自己的作用域，会增加作用域链长度)
	//多个变量声明合并
	//避免图片和iFrame等的空Src。空Src会重新加载当前页面，影响速度和效率
	//尽量避免写在HTML标签中写Style属性
//移动端性能优化：
	//尽量使用css3动画，开启硬件加速。
	//适当使用touch事件代替click事件。
	//避免使用css3渐变阴影效果。
	//可以用transform: translateZ(0)来开启硬件加速。
	//不滥用Float。Float在渲染时计算量比较大，尽量减少使用
	//不滥用Web字体。Web字体需要下载，解析，重绘当前页面，尽量减少使用。
	//合理使用requestAnimationFrame动画代替setTimeout
	//CSS中的属性（CSS3 transitions、CSS3 3D transforms、Opacity、Canvas、WebGL、Video）会触发GPU渲染	//，请合理使用。过渡使用会引发手机过耗电增加
	//PC端的在移动端同样适用
	
/************************************************************************************************/

//谈谈快速排序并使用代码实现一个快速排序：
	//“快速排序”的思想很简单，整个排序过程只需要三步：
　　//（1）在数据集之中，找一个基准点
　　//（2）建立两个数组，分别存储左边和右边的数组
　　//（3）利用递归进行下次比较
	//快速排序代码实现：
     function quickSort(arr){
         if(arr.length<=1){
             return arr;//如果数组只有一个数，就直接返回；
         }
         var num = Math.floor(arr.length/2);//找到中间数的索引值，如果是浮点数，则向下取整
         var numValue = arr.splice(num,1);//找到中间数的值
         var left = [];
         var right = [];
         for(var i=0;i<arr.length;i++){
             if(arr[i]<numValue){
                 left.push(arr[i]);//基准点的左边的数传到左边数组
             }
             else{
                right.push(arr[i]);//基准点的右边的数传到右边数组
             }
         }
         return quickSort(left).concat([numValue],quickSort(right));//递归不断重复比较
     }
     alert(quickSort([32,45,37,16,2,87]));//弹出“2,16,32,37,45,87”

/************************************************************************************************/

//你觉得jQuery或zepto源码有哪些写的好的地方:
	//jQuery源码封装在一个匿名函数的自执行环境中，有助于防止变量的全局污染，然后通过传入window对象参数，可以使window对象作为局部变量使用，好处是当jQuery中访问window对象的时候，就不用将作用域链退回到顶层作用域了，从而可以更快的访问window对象。同样，传入undefined参数，可以缩短查找undefined时的作用域链。
		//下面是实现的具体方式：
		(function( window, undefined ) {
         //用一个函数域包起来，就是所谓的沙箱
         //在这里边var定义的变量，属于这个函数域内的局部变量，避免污染全局
         //把当前沙箱需要的外部变量通过函数参数引入进来
         //只要保证参数对内提供的接口的一致性，你还可以随意替换传进来的这个参数
        window.jQuery = window.$ = jQuery;
    })( window );
  //jquery将一些原型属性和方法封装在了jquery.prototype中，为了缩短名称，又赋值给了jquery.fn，这是很形象的写法。有一些数组或对象的方法经常能使用到，jQuery将其保存为局部变量以提高访问速度。jquery实现的链式调用可以节约代码，所返回的都是同一个对象，可以提高代码效率。

/************************************************************************************************/

//对ES6的了解：
	//新增模板字符串（为JavaScript提供了简单的字符串插值功能）、箭头函数（操作符左边为输入的参数，而右边则是进行的操作以及返回的值Inputs=>outputs。）、for-of（用来遍历数据—例如数组中的值。）arguments对象可被不定参数和默认参数完美代替。ES6将promise对象纳入规范，提供了原生的Promise对象。增加了let和const命令，用来声明变量。增加了块级作用域。let命令实际上就增加了块级作用域。ES6规定，var命令和function命令声明的全局变量，属于全局对象的属性；let命令、const命令、class命令声明的全局变量，不属于全局对象的属性。还有就是引入module模块的概念;
	
/************************************************************************************************/

//JS中继承主流的实现方式，有以下几种：
 	//1、基于原型链实现继承
 	//      a、扩展原型对象
 	//      b、替换原型对象
 	//2、混入继承(拷贝继承)--->jQuery:$.extend
 	//                      $.fn.extend
 	//3、原型式继承(经典继承)--->道格拉斯：Object.create()	
 	//4、借用构造函数实现继承
 	
//对js继承的详细解释：
//JS中的继承：某个对象可以访问到另一个对象中的属性和方法，我们认为它们之间存在继承关系；
  //js中继承的主流实现方式：
  	//1.基于原型链实现继承
    	//1.a.扩展原型对象实现继承--一个函数创建好之后，就会有一个默认的原型对象，给这个对象添加属性和方法，我们把这样的方式成为扩展原型对象继承；
			//1.b.替换原型对象实现继承--当使用扩展原型对象来实现给原型对象扩展多个属性和方法的时候，会出现一些重复的代码，将这些重复代码封装，即给构造函数添加一个新的原型对象，并使构造函数指向新的原型对象；
		//2.原型式继承（经典继承）--创建一个新的对象，让新的对象可以继承自指定的对象，从而这个新的对象既可以访问到自己的属性，也可以访问到指定的对象的属性；
		//tip:现代浏览器中，Object.create()实现了原型式继承；
		//3.混入继承--使用for...in循环将某个对象中的属性分别拷贝到另一个对象中，最大限度的减少重复代码；
		//4.借用构造函数实现继承--至少有两个构造函数（Parent,Child）,如果Parent中的代码完全适用于Child,可以在Child函数内部使用上下文模式执行Parent构造函数，从而给Child实例添加属性；如果Parent属性不完全适用于Child,不建议使用构造函数；
		
/************************************************************************************************/

//谈谈你对闭包的理解：
	//使用闭包主要是为了设计私有的方法和变量。闭包的优点是可以避免全局变量的污染，缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。在js中，函数即闭包，只有函数才会产生作用域的概念;
	//闭包的三个特性：
		//1.函数嵌套函数
		//2.函数内部可以引用外部的参数和变量
		//3.参数和变量不会被垃圾回收机制回收
	//一道闭包经典面试题：
		<ul>
		    <li>111</li>
		    <li>222</li>
		    <li>333</li>
		    <li>444</li>
		    <li>555</li>
		</ul>
		<script>
		    var lis = document.querySelectorAll("li");
		    for (var i = 0; i < lis.length; i++) {
		        var li = lis[i];
		        li.onclick = (function () {
		            var j = i;
		            return function () {
		                alert(lis[j].innerText);
		            }
		        })();
		    }
    //分析：
    //for循环中给每一个li标签绑定单机事件，在每一次绑定的时候，调用一个自执行函数
    //第一次循环--->第一个自执行函数，创建变量j=0，最后返回一个闭包函数，这个闭包函数可以访问到这个j=0，这个函数被赋值给第一个li标签的单击事件
    //第二次循环--->第二个自执行函数，创建变量j=1，最后返回这个闭包函数，这个闭包函数中可以访问到j=1，这个函数被赋值给第二个li标签的单击事件
		

/************************************************************************************************/

//关于跨域以及如何解决跨域：
	//跨域：
		//跨域是指通过js在不同的域之间进行数据传输或通信，比如用ajax向一个不同的域请求数据，或者通过js获取页面中不同域的框架中(iframe)的数据。只要协议、域名、端口有任何一个不同，都被当作是不同的域。
	//如何解决跨域：
		//1.Jsonp：
			//在js中，我们直接用XMLHttpRequest请求不同域上的数据时，是不可以的。但是，在页面上引入不同域上的js脚本文件却是可以的，jsonp正是利用这个特性来实现的。
			//jsonp的原理--通过script标签引入一个js文件，这个js文件载入成功后会执行我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入。所以jsonp是需要服务器端的页面进行相应的配合的。
		//2.在服务器上设置代理页面；
		//3.通过修改document.domain来跨子域：
 			//当主域名相同的时候，可以设置不同页面的document.domain都为主域名就可以实现跨域；
		//4.使用window.name进行跨域；
		//5.使用HTML5中新引进的window.postMessage方法来跨域传送数据；

/************************************************************************************************/

//对BFC规范的理解：
	// BFC，块级格式化上下文，一个创建了新的BFC的盒子是独立布局的，盒子里面的子元素的样式不会影响到外面的元素。在同一个BFC中的两个毗邻的块级盒在垂直方向（和布局方向有关系）的margin会发生折叠。

/************************************************************************************************/

//说说你对语义化的理解：
	//1，去掉或者丢失样式的时候能够让页面呈现出清晰的结构
	//2，有利于SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重；
	//3，方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页；
	//4，便于团队开发和维护，语义化更具可读性，是下一步吧网页的重要动向，遵循W3C标准的团队都遵循这个标准，可以减少差异化。 

/************************************************************************************************/

//常见的兼容性问题以及解决方案：
	//png24位的图片在iE6浏览器上出现背景，解决方案是做成PNG8.也可以引用一段脚本处理.
	//浏览器默认的margin和padding不同。解决方案是加一个全局的*{margin:0;padding:0;}来统一。
	//IE6双边距bug:块属性标签float后，又有横行的margin情况下，在ie6显示margin比设置的大。
	//浮动ie产生的双倍距离（IE6双边距问题：在IE6下，如果对元素设置了浮动，同时又设置了margin-left或margin-right，margin值会加倍。）
	//#box{ float:left; width:10px; margin:0 0 0 100px;}
	//这种情况之下IE会产生20px的距离，解决方案是在float的标签样式控制中加入
	//_display:inline;将其转化为行内属性。(_这个符号只有ie6会识别)
	
/************************************************************************************************/

//TCP、http，https以及三次握手：
	//TCP 是传输层协议，主要解决数据如何在网络中传输的；
		//第一次握手：客户端发送请求包到服务器，等待服务器确认
		//第二次握手：服务器响应客户端请求，同时也发送一个回应包给客户端
		//第三次握手：客户端收到服务器的回应包后，向服务器发送确认包
		//握手过程中传送的包里，不包含数据，三次握手完毕后，客户端与服务端才正式的开始传递数据。
		//TCP一旦连接起来，在客户端和服务端任何一方主动关闭连接之前，TCP连接都将被一直保持下去。
		//断开连接时，服务器和客户端都可以主动发起断开TCP连接的请求。

	//HTTP(超文本传输协议)是应用层协议，主要解决怎么包装数据，它是无状态的，浏览器和服务器每进行一次http操作，就建立一次连接，但任务结束就断开连接， HTTP是利用TCP在两台电脑(通常是Web服务器和客户端)之间传输信息的协议；

	//HTTPS是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层；
	
/************************************************************************************************/

//linux常用命令行:
	//1.ls–List
	//ls会列举出当前工作目录的内容（文件或文件夹），就跟你在GUI中打开一个文件夹去看里面的内容一样。
	//2.mkdir–Make Directory
	//mkdir用于新建一个新目录
	//3.pwd–Print Working Directory
	//pwd显示当前工作目录
	//4.cd–Change Directory
	//对于当前在终端运行的会中中，cd将给定的文件夹（或目录）设置成当前工作目录。
	//5.rmdir–Remove Directory
	//rmdir删除给定的目录。
	//6.rm–Remove
	//rm会删除给定的文件或文件夹，可以使用rm -r递归删除文件夹
	//7.cp–Copy
	//cp命令对文件或文件夹进行复制，可以使用cp -r选项来递归复制文件夹。
	//8.mv–MoVe
	//mv命令对文件或文件夹进行移动，如果文件或文件夹存在于当前工作目录，还可以对文件或文件夹进行重命名。
	//9.cat–concatenate and print files
	//cat用于在标准输出（监控器或屏幕）上查看文件内容
	//10.tail–print TAIL (from last) >
	//tail默认在标准输出上显示给定文件的最后10行内容，可以使用tail -n N指定在标准输出上显示文件的最后N行内容。
	//11.less–print LESS
	//less按页或按窗口打印文件内容。在查看包含大量文本数据的大文件时是非常有用和高效的。你可以使用Ctrl+F向前翻页，Ctrl+B向后翻页。
	//12.grep
	//grep ""在给定的文件中搜寻指定的字符串。grep -i ""在搜寻时会忽略字符串的大小写，而grep -r ""则会在当前工作目录的文件中递归搜寻指定的字符串。
	//13.Find
	//这个命令会在给定位置搜寻与条件匹配的文件。你可以使用find -name的-name选项来进行区分大小写的搜寻，find -iname来进行不区分大小写的搜寻。
	//14.tar
	//tar命令能创建、查看和提取tar压缩文件。tar -cvf是创建对应压缩文件，tar -tvf来查看对应压缩文件，tar -xvf来提取对应压缩文件。
	//15.gzip
	//gzip命令创建和提取gzip压缩文件，还可以用gzip -d来提取压缩文件。
	//16.unzip
	//unzip对gzip文档进行解压。在解压之前，可以使用unzip -l命令查看文件内容。
	//17.help
	//--help会在终端列出所有可用的命令,可以使用任何命令的-h或-help选项来查看该命令的具体用法。
	//18.whatis–What is this command
	//whatis会用单行来描述给定的命令。
	//19.man–Manual
	//man会为给定的命令显示一个手册页面。
	//20.exit
	//exit用于结束当前的终端会话。
	//21.ping
	//ping通过发送数据包ping远程主机(服务器)，常用与检测网络连接和服务器状态。
	//22.who–Who Is logged in
	//who能列出当前登录的用户名。
	//23.su–Switch User
	//su用于切换不同的用户。即使没有使用密码，超级用户也能切换到其它用户。
	//24.uname
	//uname会显示出关于系统的重要信息，如内核名称、主机名、内核版本、处理机类型等等，使用uname -a可以查看所有信息。
	//25.free–Free memory
	//free会显示出系统的空闲内存、已经占用内存、可利用的交换内存等信息，free -m将结果中的单位转换成KB，而free–g则转换成GB。
	//26.df–Disk space Free
	//df查看文件系统中磁盘的使用情况–硬盘已用和可用的存储空间以及其它存储设备。你可以使用df -h将结果以人类可读的方式显示。
	//27.ps–ProcesseS
	//ps显示系统的运行进程。
	//28.Top–TOP processes
	//top命令会默认按照CPU的占用情况，显示占用量较大的进程,可以使用top -u查看某个用户的CPU使用排名情况。
	//29.shutdown
	//shutdown用于关闭计算机，而shutdown -r用于重启计算机。

	/************************************************************************************************/


</script>
</body>
</html>